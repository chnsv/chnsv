#include <iostream>
#include <vector>

using namespace std;

int k = 0;
vector<vector<int>> M1, M2, Res;

void Generate(vector<vector<int>> &A, int n) {
    for (int i = 0; i < n; i++) {
        vector<int>res;
        for (int j = 0; j < n; j++) {
            res.push_back(rand() % 9);
        }
        A.push_back(res);
    }
}
void GenerateNull(int n) {
    for (int i = 0; i < n; i++) {
        vector<int> res;
        for (int j = 0; j < n; j++)
            res.push_back(0);
        Res.push_back(res);
    }
}

void print(vector< vector<int> > A, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << A[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
}

// Функция для сложения двух матриц
void Add(vector<vector<int>>& M1, vector<vector<int>>& M2, vector<vector<int>>& Res, int count) {
    for (int i = 0; i < count; i++) {
        for (int j = 0; j < count; j++) {
            Res[i][j] = M1[i][j] + M2[i][j];
            k++; // Увеличиваем счетчик скалярных операций
        }
    }
}

// Функция для вычитания двух матриц
void Sub(vector<vector<int>>& M1, vector<vector<int>>& M2, vector<vector<int>>& Res, int count) {
    for (int i = 0; i < count; i++) {
        for (int j = 0; j < count; j++) {
            Res[i][j] = M1[i][j] - M2[i][j];
            k++; // Увеличиваем счетчик скалярных операций
        }
    }
}

// Функция для перемножения квадратных матриц по методу Штрассена с учетом количества скалярных операций
void StrassenMult(vector<vector<int>>& M1, vector<vector<int>>& M2, vector<vector<int>>& Res, int n) {
    if (n == 1) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int d = 0; d < n; d++) {
                    Res[i][j] += M1[i][j] * M2[j][d];
                    k += 2; // Увеличиваем счетчик скалярных операций
                }
            }
        }
    }
    else {
        // Разбиваем матрицы на четыре части
        int newSize = n / 2;
        vector<vector<int>> A11(newSize, vector<int>(newSize));
        vector<vector<int>> A12(newSize, vector<int>(newSize));
        vector<vector<int>> A21(newSize, vector<int>(newSize));
        vector<vector<int>> A22(newSize, vector<int>(newSize));

        vector<vector<int>> B11(newSize, vector<int>(newSize));
        vector<vector<int>> B12(newSize, vector<int>(newSize));
        vector<vector<int>> B21(newSize, vector<int>(newSize));
        vector<vector<int>> B22(newSize, vector<int>(newSize));

        vector<vector<int>> C11(newSize, vector<int>(newSize));
        vector<vector<int>> C12(newSize, vector<int>(newSize));
        vector<vector<int>> C21(newSize, vector<int>(newSize));
        vector<vector<int>> C22(newSize, vector<int>(newSize));

        vector<vector<int>> P1(newSize, vector<int>(newSize));
        vector<vector<int>> P2(newSize, vector<int>(newSize));
        vector<vector<int>> P3(newSize, vector<int>(newSize));
        vector<vector<int>> P4(newSize, vector<int>(newSize));
        vector<vector<int>> P5(newSize, vector<int>(newSize));
        vector<vector<int>> P6(newSize, vector<int>(newSize));
        vector<vector<int>> P7(newSize, vector<int>(newSize));

        vector<vector<int>> res1(newSize, vector<int>(newSize));
        vector<vector<int>> res2(newSize, vector<int>(newSize));

        // Заполняем части матриц
        for (int i = 0; i < newSize; i++) {
            for (int j = 0; j < newSize; j++) {
                A11[i][j] = M1[i][j];
                A12[i][j] = M1[i][j + newSize];
                A21[i][j] = M1[i + newSize][j];
                A22[i][j] = M1[i + newSize][j + newSize];

                B11[i][j] = M2[i][j];
                B12[i][j] = M2[i][j + newSize];
                B21[i][j] = M2[i + newSize][j];
                B22[i][j] = M2[i + newSize][j + newSize];
            }
        }
        // Вычисляем вспомогательные матрицы
        // P1 = (A12 - A22) * (B21 + B22)
        Sub(A12, A22, res1, newSize);
        Add(B21, B22, res2, newSize);
        StrassenMult(res1, res2, P1, newSize);
        // P2 = (A11 + A22) * (B11 + B22)
        Add(A11, A22, res1, newSize);
        Add(B11, B22, res2, newSize);
        StrassenMult(res1, res2, P2, newSize);
        // P3 = (A11 - A21) * (B11 + B12)
        Sub(A11, A21, res1, newSize);
        Add(B11, B12, res2, newSize);
        StrassenMult(res1, res2, P3, newSize);
        // P4 = (A11 + A12) * B22
        Add(A11, A12, res1, newSize);
        StrassenMult(res1, B22, P4, newSize);
        // P5 = A11 * (B12 - B22)
        Sub(B12, B22, res2, newSize);
        StrassenMult(A11, res2, P5, newSize);
        // P6 = A22 * (B21 - B11)
        Sub(B21, B11, res2, newSize);
        StrassenMult(A22, res2, P6, newSize);
        // P7 = (A21 + A22) * B11
        Add(A21, B22, res1, newSize);
        StrassenMult(res1, B11, P7, newSize);
        // Вычисляем части результирующей матрицы
        //C11 = P1 + P2 - P6 + P4
        Add(P1, P2, res1, newSize);
        Add(res1, P6, res2, newSize);
        Sub(res2, P4, C11, newSize);
        //C12 = P4 + P5
        Add(P4, P5, C12, newSize);
        //C21 P6 + P7
        Add(P6, P7, C21, newSize);
        //C22 = P2 - P3 + P5 - P7
        Sub(P2, P3, res1, newSize);
        Add(res1, P5, res2, newSize);
        Sub(res2, P7, C22, newSize);

        // Собираем результирующую матрицу из частей
        for (int i = 0; i < newSize; i++) {
            for (int j = 0; j < newSize; j++) {
                Res[i][j] = C11[i][j];
                Res[i][j + newSize] = C12[i][j];
                Res[i + newSize][j] = C21[i][j];
                Res[i + newSize][j + newSize] = C22[i][j];
            }
        }
    }
}

int main()
{
    for (int i = 2; i <= 1024; i *= 2)
    {
        Generate(M1, i);
        //print(M1, i);
        Generate(M2, i);
        //print(M2, i);
        //GenerateNull(i);
        k = 0;
        StrassenMult(M1, M2, Res, i);
        cout << i << ":\t" << k << endl;
        //M1.clear();
        //M2.clear();
        //Res.clear();
    }
    return 0;
}
